use rand::Rng;
use std::fs::read_to_string;
use std::io;
use std::io::Write;

// ███████╗███╗   ██╗    ████████╗ ██████╗      ██████╗ ███████╗████████╗
// ██╔════╝████╗  ██║    ╚══██╔══╝██╔═══██╗    ██╔════╝ ██╔════╝╚══██╔══╝
// █████╗  ██╔██╗ ██║       ██║   ██║   ██║    ██║  ███╗█████╗     ██║
// ██╔══╝  ██║╚██╗██║       ██║   ██║   ██║    ██║   ██║██╔══╝     ██║
// ██║     ██║ ╚████║       ██║   ╚██████╔╝    ╚██████╔╝███████╗   ██║
// ╚═╝     ╚═╝  ╚═══╝       ╚═╝    ╚═════╝      ╚═════╝ ╚══════╝   ╚═╝
//            ██╗   ██╗     ██████╗ ██████╗     ███╗   ██╗
//            ╚██╗ ██╔╝    ██╔═══██╗██╔══██╗    ████╗  ██║
//             ╚████╔╝     ██║   ██║██████╔╝    ██╔██╗ ██║
//              ╚██╔╝      ██║   ██║██╔══██╗    ██║╚██╗██║
//               ██║       ╚██████╔╝██║  ██║    ██║ ╚████║
//               ╚═╝        ╚═════╝ ╚═╝  ╚═╝    ╚═╝  ╚═══╝
//            ██╗███╗   ██╗██████╗ ██╗   ██╗████████╗███████╗
//            ██║████╗  ██║██╔══██╗██║   ██║╚══██╔══╝██╔════╝
//            ██║██╔██╗ ██║██████╔╝██║   ██║   ██║   ███████╗
//            ██║██║╚██╗██║██╔═══╝ ██║   ██║   ██║   ╚════██║
//            ██║██║ ╚████║██║     ╚██████╔╝   ██║   ███████║
//            ╚═╝╚═╝  ╚═══╝╚═╝      ╚═════╝    ╚═╝   ╚══════╝

fn get_verefied_inputs(allowed_input1: &str, allowed_input2: &str, prompt: &str) -> String {
    let mut user_answer = String::new();

    while user_answer != allowed_input1 && user_answer != allowed_input2 {
        print!("{}({}/{}): ", prompt, allowed_input1, allowed_input2);

        //this line clears the standard output stream, fixing a bug with the print! macro. I found this code at https://stackoverflow.com/questions/77197962
        io::stdout().flush().unwrap();

        //get an input from the user and trim their input
        let _ = io::stdin().read_line(&mut user_answer);
        user_answer = user_answer.trim().to_string();
        println!();

        if user_answer != allowed_input1 && user_answer != allowed_input2 {
            println!(
                "That is not a valid input. Valid inputs are '{}' or '{}'.\n",
                allowed_input1, allowed_input2
            );
            //clear to avoid cotinuosly adding to variable and never matching conditionals
            user_answer.clear();
        }
    }

    return user_answer;
}

// ███████╗███╗   ██╗    ████████╗ ██████╗      ██████╗██╗     ███████╗ █████╗ ██████╗
// ██╔════╝████╗  ██║    ╚══██╔══╝██╔═══██╗    ██╔════╝██║     ██╔════╝██╔══██╗██╔══██╗
// █████╗  ██╔██╗ ██║       ██║   ██║   ██║    ██║     ██║     █████╗  ███████║██████╔╝
// ██╔══╝  ██║╚██╗██║       ██║   ██║   ██║    ██║     ██║     ██╔══╝  ██╔══██║██╔══██╗
// ██║     ██║ ╚████║       ██║   ╚██████╔╝    ╚██████╗███████╗███████╗██║  ██║██║  ██║
// ╚═╝     ╚═╝  ╚═══╝       ╚═╝    ╚═════╝      ╚═════╝╚══════╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝
// ████████╗██╗  ██╗███████╗    ███████╗ ██████╗██████╗ ███████╗███████╗███╗   ██╗
// ╚══██╔══╝██║  ██║██╔════╝    ██╔════╝██╔════╝██╔══██╗██╔════╝██╔════╝████╗  ██║
//    ██║   ███████║█████╗      ███████╗██║     ██████╔╝█████╗  █████╗  ██╔██╗ ██║
//    ██║   ██╔══██║██╔══╝      ╚════██║██║     ██╔══██╗██╔══╝  ██╔══╝  ██║╚██╗██║
//    ██║   ██║  ██║███████╗    ███████║╚██████╗██║  ██║███████╗███████╗██║ ╚████║
//    ╚═╝   ╚═╝  ╚═╝╚══════╝    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝╚═╝  ╚═══╝

//this code was generated by ChatGPT to clear the terminal screen on all operating systems
fn clear_screen() {
    #[cfg(target_os = "windows")]
    let _ = std::process::Command::new("cmd")
        .arg("/c")
        .arg("cls")
        .status();

    #[cfg(not(target_os = "windows"))]
    let _ = Command::new("clear").status();
}

// ███████╗███╗   ██╗    ████████╗ ██████╗     ██╗      ██████╗  █████╗ ██████╗
// ██╔════╝████╗  ██║    ╚══██╔══╝██╔═══██╗    ██║     ██╔═══██╗██╔══██╗██╔══██╗
// █████╗  ██╔██╗ ██║       ██║   ██║   ██║    ██║     ██║   ██║███████║██║  ██║
// ██╔══╝  ██║╚██╗██║       ██║   ██║   ██║    ██║     ██║   ██║██╔══██║██║  ██║
// ██║     ██║ ╚████║       ██║   ╚██████╔╝    ███████╗╚██████╔╝██║  ██║██████╔╝
// ╚═╝     ╚═╝  ╚═══╝       ╚═╝    ╚═════╝     ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝
// ███████╗██╗██╗     ███████╗    ██╗███╗   ██╗████████╗ ██████╗      █████╗
// ██╔════╝██║██║     ██╔════╝    ██║████╗  ██║╚══██╔══╝██╔═══██╗    ██╔══██╗
// █████╗  ██║██║     █████╗      ██║██╔██╗ ██║   ██║   ██║   ██║    ███████║
// ██╔══╝  ██║██║     ██╔══╝      ██║██║╚██╗██║   ██║   ██║   ██║    ██╔══██║
// ██║     ██║███████╗███████╗    ██║██║ ╚████║   ██║   ╚██████╔╝    ██║  ██║
// ╚═╝     ╚═╝╚══════╝╚══════╝    ╚═╝╚═╝  ╚═══╝   ╚═╝    ╚═════╝     ╚═╝  ╚═╝
// ██╗   ██╗███████╗ ██████╗████████╗ ██████╗ ██████╗
// ██║   ██║██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗
// ██║   ██║█████╗  ██║        ██║   ██║   ██║██████╔╝
// ╚██╗ ██╔╝██╔══╝  ██║        ██║   ██║   ██║██╔══██╗
//  ╚████╔╝ ███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║
//   ╚═══╝  ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝

//this code was originally generated by ChatGPT to read a text file, iterate through, splitting entries on the ", " delimeter and adding each item to a vector
//after seeing a possible solution, I deleted their function and wrote it again myself, asking questions about syntax/error handling when I was stuck
//On 5/12/24 I re-wrote this function on my own to use a file location as a parameter.
//this function looks and behaves wildly different than when chatgpt wrote it
fn txt_to_vector(file_location: &str, delimeter: &str) -> Vec<String> {
    let mut temp_vector: Vec<String> = Vec::new();
    //saves data from a text file as data
    let data = read_to_string(file_location).expect("There was a big probleem");

    // iterates through data, splits on the delimeter, pushes to a vector, and returns that vector
    let entries: Vec<&str> = data.split(delimeter).collect();
    for entry in entries {
        temp_vector.push(entry.to_string());
    }
    return temp_vector;
}

// ███████╗███╗   ██╗    ████████╗ ██████╗      ██████╗██╗  ██╗███████╗ ██████╗██╗  ██╗
// ██╔════╝████╗  ██║    ╚══██╔══╝██╔═══██╗    ██╔════╝██║  ██║██╔════╝██╔════╝██║ ██╔╝
// █████╗  ██╔██╗ ██║       ██║   ██║   ██║    ██║     ███████║█████╗  ██║     █████╔╝
// ██╔══╝  ██║╚██╗██║       ██║   ██║   ██║    ██║     ██╔══██║██╔══╝  ██║     ██╔═██╗
// ██║     ██║ ╚████║       ██║   ╚██████╔╝    ╚██████╗██║  ██║███████╗╚██████╗██║  ██╗
// ╚═╝     ╚═╝  ╚═══╝       ╚═╝    ╚═════╝      ╚═════╝╚═╝  ╚═╝╚══════╝ ╚═════╝╚═╝  ╚═╝
// ██╗███████╗    ███████╗████████╗██████╗ ██╗███╗   ██╗ ██████╗     ██╗███████╗
// ██║██╔════╝    ██╔════╝╚══██╔══╝██╔══██╗██║████╗  ██║██╔════╝     ██║██╔════╝
// ██║█████╗      ███████╗   ██║   ██████╔╝██║██╔██╗ ██║██║  ███╗    ██║███████╗
// ██║██╔══╝      ╚════██║   ██║   ██╔══██╗██║██║╚██╗██║██║   ██║    ██║╚════██║
// ██║██║         ███████║   ██║   ██║  ██║██║██║ ╚████║╚██████╔╝    ██║███████║
// ╚═╝╚═╝         ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝     ╚═╝╚══════╝
//  █████╗ ██╗     ██████╗ ██╗  ██╗ █████╗ ██████╗ ███████╗████████╗██╗ ██████╗
// ██╔══██╗██║     ██╔══██╗██║  ██║██╔══██╗██╔══██╗██╔════╝╚══██╔══╝██║██╔════╝
// ███████║██║     ██████╔╝███████║███████║██████╔╝█████╗     ██║   ██║██║
// ██╔══██║██║     ██╔═══╝ ██╔══██║██╔══██║██╔══██╗██╔══╝     ██║   ██║██║
// ██║  ██║███████╗██║     ██║  ██║██║  ██║██████╔╝███████╗   ██║   ██║╚██████╗
// ╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝   ╚═╝   ╚═╝ ╚═════╝

fn is_letters(some_string: String) -> bool {
    for item in some_string.chars() {
        if !item.is_alphabetic() {
            return false;
        }
    }
    return true;
}

// ███╗   ███╗     █████╗     ██╗    ███╗   ██╗       ███████╗  ███╗   ██╗
// ████╗ ████║    ██╔══██╗    ██║    ████╗  ██║       ██╔════╝  ████╗  ██║
// ██╔████╔██║    ███████║    ██║    ██╔██╗ ██║       █████╗    ██╔██╗ ██║
// ██║╚██╔╝██║    ██╔══██║    ██║    ██║╚██╗██║       ██╔══╝    ██║╚██╗██║
// ██║ ╚═╝ ██║    ██║  ██║    ██║    ██║ ╚████║       ██║       ██║ ╚████║
// ╚═╝     ╚═╝    ╚═╝  ╚═╝    ╚═╝    ╚═╝  ╚═══╝       ╚═╝       ╚═╝  ╚═══╝

fn main() {
    // ██╗      ██████╗  ██████╗ ██████╗     ████████╗ ██████╗
    // ██║     ██╔═══██╗██╔═══██╗██╔══██╗    ╚══██╔══╝██╔═══██╗
    // ██║     ██║   ██║██║   ██║██████╔╝       ██║   ██║   ██║
    // ██║     ██║   ██║██║   ██║██╔═══╝        ██║   ██║   ██║
    // ███████╗╚██████╔╝╚██████╔╝██║            ██║   ╚██████╔╝
    // ╚══════╝ ╚═════╝  ╚═════╝ ╚═╝            ╚═╝    ╚═════╝
    //  █████╗ ██╗     ██╗      ██████╗ ██╗    ██╗
    // ██╔══██╗██║     ██║     ██╔═══██╗██║    ██║
    // ███████║██║     ██║     ██║   ██║██║ █╗ ██║
    // ██╔══██║██║     ██║     ██║   ██║██║███╗██║
    // ██║  ██║███████╗███████╗╚██████╔╝╚███╔███╔╝
    // ╚═╝  ╚═╝╚══════╝╚══════╝ ╚═════╝  ╚══╝╚══╝
    // ██████╗ ███████╗██████╗ ██╗      █████╗ ██╗   ██╗██╗███╗   ██╗ ██████╗
    // ██╔══██╗██╔════╝██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝██║████╗  ██║██╔════╝
    // ██████╔╝█████╗  ██████╔╝██║     ███████║ ╚████╔╝ ██║██╔██╗ ██║██║  ███╗
    // ██╔══██╗██╔══╝  ██╔═══╝ ██║     ██╔══██║  ╚██╔╝  ██║██║╚██╗██║██║   ██║
    // ██║  ██║███████╗██║     ███████╗██║  ██║   ██║   ██║██║ ╚████║╚██████╔╝
    // ╚═╝  ╚═╝╚══════╝╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝

    let mut meta_game: bool = true;
    while meta_game {
        //
        // ██╗      ██████╗  █████╗ ██████╗
        // ██║     ██╔═══██╗██╔══██╗██╔══██╗
        // ██║     ██║   ██║███████║██║  ██║
        // ██║     ██║   ██║██╔══██║██║  ██║
        // ███████╗╚██████╔╝██║  ██║██████╔╝
        // ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝
        //
        // ██████╗ ██╗ ██████╗████████╗██╗   ██╗██████╗ ███████╗███████╗
        // ██╔══██╗██║██╔════╝╚══██╔══╝██║   ██║██╔══██╗██╔════╝██╔════╝
        // ██████╔╝██║██║        ██║   ██║   ██║██████╔╝█████╗  ███████╗
        // ██╔═══╝ ██║██║        ██║   ██║   ██║██╔══██╗██╔══╝  ╚════██║
        // ██║     ██║╚██████╗   ██║   ╚██████╔╝██║  ██║███████╗███████║
        // ╚═╝     ╚═╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝
        //
        //  █████╗ ███╗   ██╗██████╗      █████╗ ██████╗ ████████╗
        // ██╔══██╗████╗  ██║██╔══██╗    ██╔══██╗██╔══██╗╚══██╔══╝
        // ███████║██╔██╗ ██║██║  ██║    ███████║██████╔╝   ██║
        // ██╔══██║██║╚██╗██║██║  ██║    ██╔══██║██╔══██╗   ██║
        // ██║  ██║██║ ╚████║██████╔╝    ██║  ██║██║  ██║   ██║
        // ╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝     ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝
        //

        // all bold ascii text was generated via this website: https://patorjk.com/software/taag/#p=display&v=0&f=ANSI%20Shadow&t=something
        // load in ascii art from art.txt
        let art_vector: Vec<String>;

        art_vector = txt_to_vector("src//art.txt", "`1234567890-=");

        //load a vector to hold my ascii art of gallows and various stages of hanged man
        // all of the hangman/gallows art was generated by ChatGPT 3.5 and modified by me to have 2 hanged men
        let pictures: Vec<String>;
        pictures = txt_to_vector("src//pictures.txt", "`1234567890-=");

        //clear the screen
        clear_screen();

        //display main menu text
        println!("{}", art_vector[1]);

        // ██████╗ ███████╗███████╗██╗███╗   ██╗███████╗
        // ██╔══██╗██╔════╝██╔════╝██║████╗  ██║██╔════╝
        // ██║  ██║█████╗  █████╗  ██║██╔██╗ ██║█████╗
        // ██║  ██║██╔══╝  ██╔══╝  ██║██║╚██╗██║██╔══╝
        // ██████╔╝███████╗██║     ██║██║ ╚████║███████╗
        // ╚═════╝ ╚══════╝╚═╝     ╚═╝╚═╝  ╚═══╝╚══════╝
        //  ██████╗ ██╗      ██████╗ ██████╗  █████╗ ██╗               ██╗███████╗██╗  ██╗
        // ██╔════╝ ██║     ██╔═══██╗██╔══██╗██╔══██╗██║               ██║██╔════╝██║  ██║
        // ██║  ███╗██║     ██║   ██║██████╔╝███████║██║         █████╗██║███████╗███████║
        // ██║   ██║██║     ██║   ██║██╔══██╗██╔══██║██║         ╚════╝██║╚════██║██╔══██║
        // ╚██████╔╝███████╗╚██████╔╝██████╔╝██║  ██║███████╗          ██║███████║██║  ██║
        //  ╚═════╝ ╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝          ╚═╝╚══════╝╚═╝  ╚═╝
        // ██╗   ██╗ █████╗ ██████╗ ██╗ █████╗ ██████╗ ██╗     ███████╗███████╗
        // ██║   ██║██╔══██╗██╔══██╗██║██╔══██╗██╔══██╗██║     ██╔════╝██╔════╝
        // ██║   ██║███████║██████╔╝██║███████║██████╔╝██║     █████╗  ███████╗
        // ╚██╗ ██╔╝██╔══██║██╔══██╗██║██╔══██║██╔══██╗██║     ██╔══╝  ╚════██║
        //  ╚████╔╝ ██║  ██║██║  ██║██║██║  ██║██████╔╝███████╗███████╗███████║
        //   ╚═══╝  ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝╚══════╝

        //ask the user if they are playing with 1 hanged man (6 wrong guesses) or 2 (12 wrong guesses)
        let wrong_guesses_until_loss: usize =
            get_verefied_inputs("6", "12", "How many incorrect guesses are allowed?")
                .parse()
                .unwrap();

        //define victory/loss bool
        let mut win: bool = false;
        //define a bool make the main game loop of entering guesses and recievieng feedback continue
        let mut keep_going: bool = true;

        //define a variable to hold normal guesses
        let mut guess = String::new();
        // define variable to hold a guess made after typing solve
        let mut solve_guess = String::new();

        //create a vector and give it the value of the temp_vector from the function txt_to_vector
        //credits to alpha-tango on github, as they provided the word bank for hangman. I got the data from this link: https://gist.github.com/alpha-tango/c3d2645817cf4af2aa45#file-hangman_wordbank
        let mut answer_word_bank: Vec<String> = txt_to_vector("src\\word_bank.txt", ", ");
        //porcupine was the test word, I wanted to add it to the word bank
        answer_word_bank.push("porcupine".to_string());
        //define a random object and generate a random number to use as an index to assign the hidden word
        let mut rng = rand::thread_rng();
        let answer_index = rng.gen_range(0..answer_word_bank.len());
        //define the hidden word using the index generated earlier
        let answer = &answer_word_bank[answer_index];

        // define a vector to hold correct guesses
        let mut correct_guesses: Vec<String> = vec![];
        // define a vector to hold wrong guesses
        let mut incorrect_guesses: Vec<String> = vec![];
        // define a vector to hold all guesses
        let mut all_guesses: Vec<String> = vec![];

        // ███████╗████████╗ █████╗ ██████╗ ████████╗    ███╗   ███╗ █████╗ ██╗███╗   ██╗
        // ██╔════╝╚══██╔══╝██╔══██╗██╔══██╗╚══██╔══╝    ████╗ ████║██╔══██╗██║████╗  ██║
        // ███████╗   ██║   ███████║██████╔╝   ██║       ██╔████╔██║███████║██║██╔██╗ ██║
        // ╚════██║   ██║   ██╔══██║██╔══██╗   ██║       ██║╚██╔╝██║██╔══██║██║██║╚██╗██║
        // ███████║   ██║   ██║  ██║██║  ██║   ██║       ██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
        // ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝       ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
        //  ██████╗  █████╗ ███╗   ███╗███████╗    ██╗      ██████╗  ██████╗ ██████╗
        // ██╔════╝ ██╔══██╗████╗ ████║██╔════╝    ██║     ██╔═══██╗██╔═══██╗██╔══██╗
        // ██║  ███╗███████║██╔████╔██║█████╗      ██║     ██║   ██║██║   ██║██████╔╝
        // ██║   ██║██╔══██║██║╚██╔╝██║██╔══╝      ██║     ██║   ██║██║   ██║██╔═══╝
        // ╚██████╔╝██║  ██║██║ ╚═╝ ██║███████╗    ███████╗╚██████╔╝╚██████╔╝██║
        //  ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝    ╚══════╝ ╚═════╝  ╚═════╝ ╚═╝

        while keep_going {
            //have the user press enter to start the program/every loop to preserve what was just printed onto the screen
            println!("\n   Press enter to continue ");
            {
                let mut _temporary_holder = Default::default();
                io::stdin().read_line(&mut _temporary_holder).unwrap();
            }

            //clear the screen
            clear_screen();

            //display how many incorrect guesses the user has made via the corresponding gallows image
            println!("{}", pictures[incorrect_guesses.len()]);

            //         __
            //         [  |
            //   .--.   | |--.   .--.   _   _   __
            //  ( (`\]  | .-. |/ .'`\ \[ \ [ \ [  ]
            //   `'.'.  | | | || \__. | \ \/\ \/ /            _
            //  [\__) )[___]|__]'.__.'   \__/\__/            / |_
            //   .---.   .--.   _ .--.  _ .--.  .---.  .---.`| |-'
            //  / /'`\]/ .'`\ \[ `/'`\][ `/'`\]/ /__\\/ /'`\]| |
            //  | \__. | \__. | | |     | |    | \__.,| \__. | |,
            //  '.___.' '.__.' [___]   [___]    '.__.''.___.'\__/
            //    .--./) __   _   .---.  .--.   .--.  .---.  .--.
            //   / /'`\;[  | | | / /__\\( (`\] ( (`\]/ /__\\( (`\]
            //   \ \._// | \_/ |,| \__., `'.'.  `'.'.| \__., `'.'.
            //   .',__`  '.__.'_/ '.__.'[\__) )[\__) )'.__.'[\__) )
            //  ( ( __))

            //Tell the user how to play
            println!("Guess the word hidden by the blanks");
            print!("If you think you know the word, type 'solve'\n\n  ");

            //display what characters of the word that the user has guessed
            for letter in answer.chars() {
                if correct_guesses.contains(&letter.to_string()) {
                    print!("{} ", letter);
                } else {
                    print!("_ ");
                };
            }

            println!("\n");

            //         __
            //         [  |
            //   .--.   | |--.   .--.   _   _   __
            //  ( (`\]  | .-. |/ .'`\ \[ \ [ \ [  ]
            //   `'.'.  | | | || \__. | \ \/\ \/ /
            //  [\__) )[___]|__]'.__.'   \__/\__/
            //    _                                                         _
            //   (_)                                                       / |_
            //   __   _ .--.   .---.   .--.   _ .--.  _ .--.  .---.  .---.`| |-'
            //  [  | [ `.-. | / /'`\]/ .'`\ \[ `/'`\][ `/'`\]/ /__\\/ /'`\]| |
            //   | |  | | | | | \__. | \__. | | |     | |    | \__.,| \__. | |,
            //  [___][___||__]'.___.' '.__.' [___]   [___]    '.__.''.___.'\__/
            //    .--./) __   _   .---.  .--.   .--.  .---.  .--.
            //   / /'`\;[  | | | / /__\\( (`\] ( (`\]/ /__\\( (`\]
            //   \ \._// | \_/ |,| \__., `'.'.  `'.'.| \__., `'.'.
            //   .',__`  '.__.'_/ '.__.'[\__) )[\__) )'.__.'[\__) )
            //  ( ( __))

            //display list of already guessed letters
            if incorrect_guesses.len() > 0 {
                println!("Your incorrect guesses are: ");
                for incorrect_guess in &incorrect_guesses {
                    if incorrect_guesses[incorrect_guesses.len() - 1] == incorrect_guess.to_string()
                    {
                        println!("{} \n", incorrect_guess);
                    } else {
                        print!("{}, ", incorrect_guess);
                    }
                }
            } else {
                println!("You have no incorrect guesses so far")
            }

            //                _
            //               / |_
            //  .--./) .---.`| |-'   .--./) __   _   .---.  .--.   .--.
            // / /'`\;/ /__\\| |    / /'`\;[  | | | / /__\\( (`\] ( (`\]
            // \ \._//| \__.,| |,   \ \._// | \_/ |,| \__., `'.'.  `'.'.
            // .',__`  '.__.'\__/   .',__`  '.__.'_/ '.__.'[\__) )[\__) )
            // ( ( __))             ( ( __))
            //     ___                                _   __
            //   .' ..]                              / |_[  |
            //  _| |_  _ .--.   .--.   _ .--..--.   `| |-'| |--.  .---.
            // '-| |-'[ `/'`\]/ .'`\ \[ `.-. .-. |   | |  | .-. |/ /__\\
            //   | |   | |    | \__. | | | | | | |   | |, | | | || \__.,
            //  [___] [___]    '.__.' [___||__||__]  \__/[___]|__]'.__.'
            //   __   _   .--.  .---.  _ .--.
            //  [  | | | ( (`\]/ /__\\[ `/'`\]
            //   | \_/ |, `'.'.| \__., | |
            //   '.__.'_/[\__) )'.__.'[___]

            //get an input from the user. verify that this guess is unique
            println!("Guess a character!");
            print!("Please input your guess: ");

            //this line clears the standard output stream, fixing a bug with the print! macro. I found this code at https://stackoverflow.com/questions/77197962
            io::stdout().flush().unwrap();
            //get an input from the user and trim their input
            let _ = io::stdin().read_line(&mut guess);
            guess = guess.trim().to_string().to_lowercase();
            println!();

            //      _                             _
            //     (_)                           / |_
            //     __   _ .--.  _ .--.   __   _ `| |-'
            //    [  | [ `.-. |[ '/'`\ \[  | | | | |
            //     | |  | | | | | \__/ | | \_/ |,| |,
            //    [___][___||__]| ;.__/  '.__.'_/\__/
            //                 [__|        _     ___  _                 _    _
            //                            (_)  .' ..](_)               / |_ (_)
            //     _   __  .---.  _ .--.  __  _| |_  __   .---.  ,--. `| |-'__   .--.   _ .--.
            //    [ \ [  ]/ /__\\[ `/'`\][  |'-| |-'[  | / /'`\]`'_\ : | | [  |/ .'`\ \[ `.-. |
            //     \ \/ / | \__., | |     | |  | |   | | | \__. // | |,| |, | || \__. | | | | |
            //      \__/   '.__.'[___]   [___][___] [___]'.___.'\'-;__/\__/[___]'.__.' [___||__]

            //verify that this guess has not been made
            if all_guesses.contains(&guess) {
                println!(
                    "You have already guessed '{}'. Make a different guess.",
                    &guess
                );
                guess = String::new();
                continue;
            }
            if guess == "debugging lose"
                || guess == "debugging clear"
                || guess == "solve"
                || guess == "debugging win"
            {
                //debugging functionality
                if guess == "debugging lose" {
                    break;
                }
                //debugging functionality
                if guess == "debugging win" {
                    win = true;
                    break;
                }
                //debugging functionality
                if guess == "debugging clear" {
                    incorrect_guesses.clear();
                    correct_guesses.clear();
                    guess.clear();
                    continue;
                }

                //      __                  _   _                   _ _ _
                //     / _|                | | (_)                 | (_) |
                //    | |_ _   _ _ __   ___| |_ _  ___  _ __   __ _| |_| |_ _   _
                //    |  _| | | | '_ \ / __| __| |/ _ \| '_ \ / _` | | | __| | | |
                //    | | | |_| | | | | (__| |_| | (_) | | | | (_| | | | |_| |_| |
                //    |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|\__,_|_|_|\__|\__, |
                //    | |                  | |                           | | __/ |
                //    | |_ ___    ___  ___ | |_   _____    ___  __ _ _ __| ||___/
                //    | __/ _ \  / __|/ _ \| \ \ / / _ \  / _ \/ _` | '__| | | | |
                //    | || (_) | \__ \ (_) | |\ V /  __/ |  __/ (_| | |  | | |_| |
                //     \__\___/  |___/\___/|_| \_/ \___|  \___|\__,_|_|  |_|\__, |
                //                                                           __/ |
                //                                                          |___/

                //functionality to guess the word early
                if guess == "solve" {
                    print!("Enter your guess as to what the entire word is: ");
                    //this line clears the standard output stream, fixing a bug/interaction with the print!() macro. I found this code at https://stackoverflow.com/questions/77197962
                    io::stdout().flush().unwrap();
                    let _ = io::stdin().read_line(&mut solve_guess);

                    //trims solve-specific guess, and lets you win if you solve it correctly
                    solve_guess = solve_guess.trim().to_string();
                    if solve_guess == *answer {
                        win = true;
                        break;
                    }
                    //copy solve_guess to guess so that it can be added to the list of wrong guesses
                    guess = solve_guess.clone();
                }
            } else if guess.len() != 1 || guess == "\n" || !is_letters(guess.clone()) {
                println!(
                    "{} is not a valid guess. Valid guesses are 1 letter long OR 'solve'",
                    &guess
                );
                guess = String::new();
                continue;
            }

            //          __                    __         _     ___
            //         [  |                  [  |  _    (_)  .' ..]
            //   .---.  | |--.  .---.  .---.  | | / ]   __  _| |_
            //  / /'`\] | .-. |/ /__\\/ /'`\] | '' <   [  |'-| |-'
            //  | \__.  | | | || \__.,| \__.  | |`\ \   | |  | |
            //  '.___.'[___]|__]'.__.''.___.'[__|  \_] [___][___]

            //                                            _
            //                                           (_)
            //    .--./) __   _   .---.  .--.   .--.     __   .--.
            //   / /'`\;[  | | | / /__\\( (`\] ( (`\]   [  | ( (`\]
            //   \ \._// | \_/ |,| \__., `'.'.  `'.'.    | |  `'.'.
            //   .',__`  '.__.'_/ '.__.'[\__) )[\__) )  [___][\__) )
            //  ( ( __))
            //                                                _
            //                                               / |_
            //   .---.   .--.   _ .--.  _ .--.  .---.  .---.`| |-'
            //  / /'`\]/ .'`\ \[ `/'`\][ `/'`\]/ /__\\/ /'`\]| |
            //  | \__. | \__. | | |     | |    | \__.,| \__. | |,
            //  '.___.' '.__.' [___]   [___]    '.__.''.___.'\__/

            //check if guess is part of answer
            if answer.contains(&guess) {
                //if true, display message and add value of guess to vector of correct guesses
                println!("Your guess was correct!");
                correct_guesses.push(guess.clone());

                //check to see if player has guessed all of the necessary letters and wins
                {
                    let mut solved_word = String::new();
                    for letter in answer.chars() {
                        if correct_guesses.contains(&letter.to_string()) {
                            solved_word = solved_word + &letter.to_string();
                        }
                    }
                    if solved_word == *answer {
                        win = true;
                        keep_going = false;
                    }
                }
            } else {
                //if not true, display message and add to vector of incorrect guesses
                println!("Your guess was incorrect!");
                incorrect_guesses.push(guess.clone());

                //check to see if the man is fully hanged and the player loses
                if incorrect_guesses.len() >= wrong_guesses_until_loss {
                    win = false;
                    keep_going = false;
                }
            };
            //clear value of guess and vector of all guesses
            guess = String::new();
            all_guesses.clear();
            //add all items from vector of correct and incorrect guesses to vector of all guesses
            all_guesses = correct_guesses
                .iter()
                .cloned()
                .chain(incorrect_guesses.iter().cloned())
                .collect();
        }

        // ██╗███████╗    ████████╗██╗  ██╗███████╗
        // ██║██╔════╝    ╚══██╔══╝██║  ██║██╔════╝
        // ██║█████╗         ██║   ███████║█████╗
        // ██║██╔══╝         ██║   ██╔══██║██╔══╝
        // ██║██║            ██║   ██║  ██║███████╗
        // ╚═╝╚═╝            ╚═╝   ╚═╝  ╚═╝╚══════╝

        // ██████╗ ██╗      █████╗ ██╗   ██╗███████╗██████╗
        // ██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝██╔════╝██╔══██╗
        // ██████╔╝██║     ███████║ ╚████╔╝ █████╗  ██████╔╝
        // ██╔═══╝ ██║     ██╔══██║  ╚██╔╝  ██╔══╝  ██╔══██╗
        // ██║     ███████╗██║  ██║   ██║   ███████╗██║  ██║
        // ╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝

        // ██╗    ██╗██╗███╗   ██╗███████╗
        // ██║    ██║██║████╗  ██║██╔════╝
        // ██║ █╗ ██║██║██╔██╗ ██║███████╗
        // ██║███╗██║██║██║╚██╗██║╚════██║
        // ╚███╔███╔╝██║██║ ╚████║███████║
        //  ╚══╝╚══╝ ╚═╝╚═╝  ╚═══╝╚══════╝

        if win {
            //clear the screen
            clear_screen();
            //display victory text
            println!("{}", art_vector[0]);
            //their hanged man
            println!("{}\n", pictures[incorrect_guesses.len()]);
            println!("The word was {}\n", &answer);

            //display wrong user guesses
            if incorrect_guesses.len() > 0 {
                println!("Your incorrect guesses were: ");
                for incorrect_guess in &incorrect_guesses {
                    if incorrect_guesses[incorrect_guesses.len() - 1] == incorrect_guess.to_string()
                    {
                        println!("{} \n", incorrect_guess);
                    } else {
                        print!("{}, ", incorrect_guess);
                    }
                }
            } else {
                println!("Wow! You had no incorrect guesses!\n")
            }

            //have the user press enter to continue
            println!("Press enter to continue");
            {
                let mut _temporary_holder = Default::default();
                io::stdin().read_line(&mut _temporary_holder).unwrap();
            }
        }
        // ██╗███████╗    ████████╗██╗  ██╗███████╗
        // ██║██╔════╝    ╚══██╔══╝██║  ██║██╔════╝
        // ██║█████╗         ██║   ███████║█████╗
        // ██║██╔══╝         ██║   ██╔══██║██╔══╝
        // ██║██║            ██║   ██║  ██║███████╗
        // ╚═╝╚═╝            ╚═╝   ╚═╝  ╚═╝╚══════╝

        // ██████╗ ██╗      █████╗ ██╗   ██╗███████╗██████╗
        // ██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝██╔════╝██╔══██╗
        // ██████╔╝██║     ███████║ ╚████╔╝ █████╗  ██████╔╝
        // ██╔═══╝ ██║     ██╔══██║  ╚██╔╝  ██╔══╝  ██╔══██╗
        // ██║     ███████╗██║  ██║   ██║   ███████╗██║  ██║
        // ╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝

        // ██╗      ██████╗ ███████╗███████╗███████╗
        // ██║     ██╔═══██╗██╔════╝██╔════╝██╔════╝
        // ██║     ██║   ██║███████╗█████╗  ███████╗
        // ██║     ██║   ██║╚════██║██╔══╝  ╚════██║
        // ███████╗╚██████╔╝███████║███████╗███████║
        // ╚══════╝ ╚═════╝ ╚══════╝╚══════╝╚══════╝
        else {
            //clear the screen
            clear_screen();
            //display loss text
            println!("{}", art_vector[2]);
            println!("{}\n", pictures[wrong_guesses_until_loss]);
            //display what the word was
            println!("The word was {}\n", answer);
            //have the user press enter to continue
            println!("Press enter to continue\n");
            {
                let mut _temporary_holder = Default::default();
                io::stdin().read_line(&mut _temporary_holder).unwrap();
            }
        }

        //
        //      ██████╗ ██╗      █████╗ ██╗   ██╗
        //      ██╔══██╗██║     ██╔══██╗╚██╗ ██╔╝
        //      ██████╔╝██║     ███████║ ╚████╔╝
        //      ██╔═══╝ ██║     ██╔══██║  ╚██╔╝
        //      ██║     ███████╗██║  ██║   ██║
        //      ╚═╝     ╚══════╝╚═╝  ╚═╝   ╚═╝
        //
        //  █████╗  ██████╗  █████╗ ██╗███╗   ██╗██████╗
        // ██╔══██╗██╔════╝ ██╔══██╗██║████╗  ██║╚════██╗
        // ███████║██║  ███╗███████║██║██╔██╗ ██║  ▄███╔╝
        // ██╔══██║██║   ██║██╔══██║██║██║╚██╗██║  ▀▀══╝
        // ██║  ██║╚██████╔╝██║  ██║██║██║ ╚████║  ██╗
        // ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝  ╚═╝
        //

        let play_again_answer = get_verefied_inputs("y", "n", "Would you like to play again?");
        if play_again_answer == "n".to_string() {
            meta_game = false;
        } else if play_again_answer == "y".to_string() {
            meta_game = true;
        }
    }
}
